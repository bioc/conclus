---
title: "ScRNA-seq workflow CONCLUS: from CONsensus CLUSters to a meaningful CONCLUSion"
author: "Ilyess Rachedi, Polina Pavlovich, Nicolas Descostes, and Christophe Lancrin"
output:
  BiocStyle::pdf_document: default
---


# Introduction

CONCLUS is a tool for robust clustering and positive marker features selection of 
single-cell RNA-seq (sc-RNA-seq) datasets. Of note, CONCLUS does not cover the 
preprocessing steps of sequencing files obtained following next-generation 
sequencing. You can find a good resource to start with 
[here](https://scrnaseq-course.cog.sanger.ac.uk/website/index.html). 

CONCLUS is organized into the following steps:

  + Generation of multiple t-SNE plots with a range of parameters including 
    different selection of genes extracted from PCA.
  + Use the Density-based spatial clustering of applications with noise (DBSCAN)
    algorithm for idenfication of clusters in each generated t-SNE plot.
  + All DBSCAN results are combined into a cell similarity matrix.
  + The cell similarity matrix is used to define "CONSENSUS" clusters conserved
    accross the previously defined clustering solutions.
  + Identify marker genes for each concensus cluster.
  

# Getting help

Issues can be submitted directly on the Bioconductor forum. To contact us
directly write to christophe.lancrin@embl.it. The principles of this package 
were originally developed by Polina Pavlovich who is now doing her Ph.D at the
Max Planck Institute of Immunobiology and Epigenetics.


# Standard workflow

## Installation

```{r loading_conclus, results="hide", warning = FALSE, message = FALSE}
# required R >= 3.4.
if(!requireNamespace("BiocManager"))
	install.packages("BiocManager")

if(!requireNamespace("conclus"))
    BiocManager::install("conclus")
```

## Quick start

CONCLUS requires to start with a raw-count matrix with reads or unique molecular 
identifiers (UMIs). The columns of the count matrix must contain cells and the 
rows -- genes. CONCLUS needs a large number of cells to collect statistics, 
we recommend using CONCLUS if you have at least 100 cells.

```{r runConclus_first, results='hide', warning = FALSE, fig.keep = 'none', message= FALSE}

library(conclus)

## Replace by the path to the directory in which results should be written
outputDirectory <- "./YourOutputDirectory"
experimentName <- "Bergiers"
species <- "mouse"

countMatrix <- as.matrix(read.delim(file.path(system.file("extdata", 
                                package = "conclus"), 
                        "Bergiers_counts_matrix_filtered.tsv"), 
                          stringsAsFactors = FALSE))

columnsMetaData <- read.delim(file.path(system.file("extdata", 
                        package = "conclus"), "Bergiers_colData_filtered.tsv"))

                
sceObjectCONCLUS <- runCONCLUS(outputDirectory, experimentName, countMatrix, 
        species, columnsMetaData = columnsMetaData)
```

In your "outputDirectory", in the folder `Resuts`, you will find a
`heatmaps_results.pdf` with the cells similarity, the clusters similarity, and
the cells heatmap. The sub-folder `pictures` contains all tSNE with dbscan
coloration. You will also find sub-folders containing: 

  + `1_MatrixInfo`: The normalized count matrix and its meta-data for
    both rows and columns.
  + `2_TSNECoordinates`: The tSNE coordinates for each parameter of principal
    components (PCs) and perplexities.
  + `3_dbScan`: The different clusters given by DBscan according to different
    parameters. Each file gives a cluster number for each cell.
  + `4_CellSimilarityMatrix`: The matrix underlying the cells similarity
    heatmap.
  + `5_ClusterSimilarityMatrix`: The matrix underlying the clusters similarity
    heatmap.
  + `6_ConclusResult`: A table containing the result of the consensus
    clustering. This table conttains two columns: clusters-cells.
  + `7_fullMarkers`: Files containing markers for each cluster, defined by the
    consensus clustering.
  + `8_TopMarkers`: Files containing the top 10 markers for each cluster.
  + `9_genesInfos`: Files containing gene information for the top markers
    defined in the previous folder.


Further details about how all results are generated can be found below.


## Data

In this vignette, we demonstrate how to use CONCLUS on a sc-RNA-seq dataset from 
[*Bergiers et al. eLife 2018*](https://elifesciences.org/articles/29312). The design for this experiment is described in 
([*Figure 4—figure supplement 2*](https://elifesciences.org/articles/29312/figures#fig4s2)). Bergiers et al. goal was to analyze 
the effect of the simultaneous expression of eight transcription factors (8TFs): *Runx1* - and its partner - *Cbfb*, *Gata2*, 
*Tal1*, *Fli1*, *Lyl1*, *Erg* and *Lmo2* in *in vitro* differentiated embryonic stem cells (ESCs) in comparison to control. 
They knocked-in a polycistronic transgenic construct allowing to over-express eigth transcription factors (i8TFs) simultaneously 
after adding doxycycline (dox). The Empty ESC line did not have any transgene. 
There were **four conditions**: E_minus (Empty no dox), E_plus (Empty with dox), i8TFs_minus (i8TFs no dox) and i8TFs_plus 
(i8TFs with dox). 

This sc-RNA-seq experiment was performed using the SMARTer ICELL8 Single-Cell System ([Click here for more info](https://www.takarabio.com/learning-centers/automation-systems/icell8-introduction/icell8-technology-overview)). The protocol was based on 3' end RNA 
sequencing where each mRNA molecule is labeled with a unique molecular identifier (UMI) during reverse transcription in every 
single cell. The analysis performed by *Bergiers et al.* was based on the dimensionality reduction algorithm called Principal 
Component Analysis (PCA), and they found that there was a major gene expression difference between i8TFs_plus and the other three 
conditions (*Figure 4—figure supplement 2*). **However, it was not clear if other subclusters could be identified consistently in 
this dataset besides the two major clusters. In the current tutorial, we show
how CONCLUS can help to answer this question.**

Labels of the four conditions are in the *state* column of *columnsMetaData*. To avoid a bias in the clustering analysis due to the 
high expression of the eight transcription factors construct, we deleted genes *Cbfb*, *Gata2*, *Tal1*, *Fli1*, *Lyl1*, *Erg*, and *Lmo2* 
from the provided *countMatrix*. Highly abundant embryonic hemoglobins with names starting with "Hba" or "Hbb" were also excluded because 
they seemed to be a primary source of contamination.


## Test clustering

The *TestClustering* function runs one clustering round out of the 84 (default) rounds that CONCLUS normally performs. This step can be useful to determine if the default DBSCAN parameters are suitable for your dataset. 
By default, they are *dbscanEpsilon = c(1.3, 1.4, 1.5)* and *minPts = c(3,4)*. If the dashed horizontal line in the k-NN distance plot lays on the “knee” of the curve (as shown below), it means that optimal epsilon is equal
to the intersection of the line to the y-axis. In our example, optimal epsilon is 1.4 for 5-NN distance where 5 corresponds to MinPts. 

In the "test_clustering" folder under outputDirectory, the three plots below will be saved where one corresponds to the “distance_graph.pdf” (Figure1), another one to “test_tSNE.pdf” (*p[[1]]*, Figure2), and the last one will be saved as 
“test_clustering.pdf” (*p[[3]]*, Figure3).


```{r normalization_1, results="hide", warning = FALSE}

## Creation of the single-cell RNA-Seq object
scr <- singlecellRNAseq(experimentName = experimentName, 
        countMatrix     = countMatrix, 
        species         = "mouse",
        outputDirectory = outputDirectory)

## Normalization of the count matrix
scr <- normaliseCountMatrix(scr, coldata=columnsMetaData)
```


```{r testClustering, fig.height=5, fig.width=6}
p <- testClustering(scr, writeOutput=TRUE, silent=TRUE)
```


```{r testClustering_result1, eval = FALSE}
# saved as "outputDirectory/test_clustering/test_tSNE.pdf"
p[[1]]
```


```{r testClustering_result2, eval = FALSE}
# saved as "outputDirectory/test_clustering/test_clustering.pdf"
p[[2]]
```


# CONCLUS step by step

The wrapper function runCONCLUS is organized into 7 steps:

  + Normalization of the counts matrix
  + Generation of t-SNE coordinates
  + Clustering with DB-SCAN
  + Cell and cluster similarity matrix calculation
  + Plotting
  + Marker genes identification
  + Results export
  


## Normalization of the counts matrix

sc-RNA-seq datasets are quite challenging notably because of sparsity (many genes are not detected consistently yielding expression matrices with many zeroes) and also because of technical noise. 
To facilitate analysis, one needs to perform a step of normalization which allows the correction of unwanted technical and biological noises (click [here](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5549838/) for a complete review on
normalization techniques).

CONCLUS uses Scran and Scater packages for normalization. Beforehand, the function will annotate genes creating *rowData* and add statistics about cells into *columnsMetaData*. If you already have *columnsMetaData* and *rowData*, 
you can give it to the function (see manual). It will keep your columns and add new ones at the end. If you do not want to lose any cell after quality metrics check, select *alreadyCellFiltered = TRUE*, by default it is *FALSE*. 
Before *scran* and *scater* normalization, the function will call *scran::quickCluster* (see manual for details). If you want to skip this step, set *runQuickCluster = FALSE*, by default it is *TRUE*. We recommend to use
*runQuickCluster = TRUE* for medium-size datasets with 500-10000 cells. However, it can take a significant amount of time for a larger amount of cells and will not be useful for small sets of 200-300 samples. 

This function is currently limited to human and mouse.

\newline
```{r normalization_2, eval = FALSE}
scr <- normaliseCountMatrix(scr, coldata=columnsMetaData)
```

The function *normaliseCountMatrix* returns a scRNASeq object with its sceNorm slot updated. This slot contains a SingleCellExperiment object having the normalized count matrix, the colData (table with cells informations), and the rowData (table with the
genes informations). See ?SingleCellExperiment for more details. 


The rowdata can help to study cross-talk between cell types or find surface protein-coding marker genes suitable for flow cytometry. The columns with the GO terms are *go_id* and *name_1006* (see manual).

The slots can be accessed as indicated below:

\newline
```{r normalization_results}
## Accessing slots
originalMat <- getCountMatrix(scr)
SCEobject <- getSceNorm(scr)
normMat <- SingleCellExperiment::logcounts(SCEobject)

# checking what changed after the normalisation
dim(originalMat)
dim(normMat)

# show first columns and rows of the count matrix
originalMat[1:5,1:5]

# show first columns and rows of the normalized count matrix
normMat[1:5,1:5]

# visualize first rows of metadata (coldata)
coldataSCE <- as.data.frame(SummarizedExperiment::colData(SCEobject))
head(coldataSCE)

# visualize beginning of the rowdata containing gene information
rowdataSCE <- as.data.frame(SummarizedExperiment:::rowData(SCEobject))
head(rowdataSCE)
```


## Generation of t-SNE coordinates

*runCONCLUS* creates needed output folders (if you did not run *testClustering* beforehand). Then it generates an object of fourteen (by default) tables with tSNE coordinates. Fourteen because it will vary seven values of 
principal components *PCs=c(4, 6, 8, 10, 20, 40, 50)* and two values of perplexity *perplexities=c(30, 40)* in all possible combinations. 

The chosen values of PCs and perplexities can be changed if necessary. We found that this combination works well for sc-RNA-seq datasets with 400-2000 cells. If you have 4000-9000 cells and expect more than 15 clusters, 
we recommend to use more first PCs and higher perplexity, for example, *PCs=c(8, 10, 20, 40, 50, 80, 100)* and *perplexities=c(200, 240)*. For details about perplexities parameter see ‘?Rtsne’.

\newline
```{r tsne_generation, results="hide", warning = FALSE}
scr <- generateTSNECoordinates(scr)
```

Results can be explored as follows:

\newline
```{r tsne_showResults}
tsneList <- getTSNEList(scr)
head(getCoordinates(tsneList[[1]]))
```


## Clustering with DB-SCAN

Following the calculation of t-SNE coordinates, DBSCAN is run with a range of epsilon and MinPoints values which will yield a total of 84 clustering solutions (PCs x perplexities x MinPoints x epsilon). *minPoints* is the minimum 
cluster size which you assume to be meaningful for your experiment and *epsilon* is the radius around the cell where the algorithm will try to find *minPoints* dots. Optimal *epsilon* must lay on the knee of the k-NN function as 
shown in the "test_clustering/distance_graph.pdf" (See Test clustering section above).
 
\newline
```{r runDBSScan, results="hide", warning = FALSE}
scr <- runDBSCAN(scr)
```

Results can be explored as follows:

\newline
```{r dbscan_showResults}
dbscanList <- getDbscanList(scr)
clusteringList <- lapply(dbscanList, getClustering)
clusteringList[[1]][,1:10]
```

## Cell and cluster similarity matrix calculation

The above calculated results are combined together in a matrix called “cell similarity matrix”. *runDBSCAN* function returns an object of class scRNASeq with its dbscanList slot updated. The list represents 84 clustering solutions (which is equal to number of 
PCs x perplexities x MinPoints x epsilon). Since the range of cluster varies from result to result, there is no exact match between numbers in different elements of the list. Cells having the same number within an element are 
guaranteed to be in one cluster. We can calculate how many times out of 84 clustering solutions, every two cells were in one cluster and that is how we come to the similarity matrix of cells. We want to underline that a zero in the 
dbscan results means that a cell was not assigned to any cluster. Hence, cluster numbers start from one. *clusterCellsInternal* is a general method that returns an object of class scRNASeq with its cellsSimilarityMatrix slot updated.
      
\newline
```{r clusterCellsInternal, warning = FALSE}
scr <- clusterCellsInternal(scr, clusterNumber = 10)
```

```{r clusterCellsInternal_showResults}
cci <- getCellsSimilarityMatrix(scr)
cci[1:10,1:10]
```

After looking at the similarity between elements on the single-cell level, which is useful if we want to understand if there is any substructure which we did not highlight with our clustering, a "bulk" level where we pool all cells 
from a cluster into a representative "pseudo cell" can also be generated. This gives a *clusterSimilarityMatrix*:
\newline
```{r clustersSimilarityMatrix}
scr <- calculateClustersSimilarity(scr)
csm <- getClustersSimilarityMatrix(scr)
csm[1:10,1:10]
```


## Plotting


### t-SNE colored by clusters or conditions

CONCLUS generated 14 tSNE combining different values of PCs and perplexities. Each tSNE can be visualized either using coloring reflecting the results of DBScan clustering, the conditions or without colors. Here *plotClusteredTSNE*
is used to generate all these possibilities of visualization. 

\newline
```{r plotClustered}
tSNEclusters <- plotClusteredTSNE(scr, columnName="clusters", 
                returnPlot=TRUE, silentPlot=TRUE)
                
tSNEnoColor <- plotClusteredTSNE(scr, columnName="noColor", 
                returnPlot=TRUE, silentPlot=TRUE)
                
tSNEstate <- plotClusteredTSNE(scr, columnName="state", 
                returnPlot=TRUE, silentPlot=TRUE)                
```

For visualizing the 5th (on 14) tSNE cluster (figure 4):
\newline
```{r plotClustered_visualization1}
tSNEclusters[[5]]
```

For visualizing the 5th (on 14) tSNE cluster without colors (figure 5):
\newline
```{r plotClustered_visualization2}
tSNEnoColor[[5]]
```

For visualizing the 5th (on 14) tSNE cluster colored by state (figure 6):
\newline
```{r plotClustered_visualization3}
tSNEstate[[5]]
```

### Cell similarity heatmap

The *cellsSimilarityMatrix* is then used to generate a heatmap (Figure 7) summarizing the results of the clustering and to show how stable the cell clusters are across the 84 solutions.
\newline
```{r plotCellSimilarity, warning = FALSE}
plotCellSimilarity(scr)
```

*CellsSimilarityMatrix* is symmetrical and its size proportional of to the "number of cells x number of cells". Each vertical or horizontal tiny strip is a cell. Intersection shows the proportion of clustering iterations in which a 
pair of cells were in one cluster (score between 0 and 1, between blue and red). We will call this combination "consensus clusters" and use them everywhere later. We can appreciate that cellsSimilarityMatrix is the first evidence 
showing that CONCLUS managed not only to distinguish i8TFs_plus cells from the three other groups (as in the original publication) but also find sub-populations within these groups which were impossible using PCA alone.

### Cluster similarity heatmap

```{r plotClustersSimilarity, warning = FALSE, message = FALSE}  
plotClustersSimilarity(scr)
```

In the *clusterSimilarityMatrix*, we can still see two major families of clusters: clusters with 8, 9, and 10 on one side and 1, 2, 3, 4, 5, 6 and 7, on the other. Almost all clusters have a high value of similarity across all clustering 
solutions. Only clusters 5-6 have a quite low similarity value. Red color on the diagonal means that the group is homogenous, and usually, it is what we want to get. The yellow on the diagonal indicates that either 
that group consists of two or more equal sized subgroups. Bluish color points to a cluster of dbscan "outliers" that usually surrounds dense clouds of cells in t-SNE plots. 


## Marker genes identification

To understand the nature of the consensus clusters identified by CONCLUS, it is essential to identify genes which could be classified as marker genes for each cluster. To this aim, each gene should be "associated" to a particular cluster. This association is performed by looking at up-regulated 
genes in a particular cluster compared to the others (multiple comparisons). The function *rankGenes* performs multiple comparisons of all genes from theObject and rank them according to a score reflecting a FDR power.

In summary, the function *conclus::rankGenes()* gives a list of marker genes for each cluster, ordered by their significance. See ?rankGenes for more details.
\newline
```{r rankGenes, message = FALSE}
scr <- rankGenes(scr)
```

```{r rankGenes_result}
markers <- getMarkerGenesList(scr)
head(markers[[1]])
```

The top 10 markers by cluster (default) can be selected with:

\newline
```{r topMarkers_result}
scr <- retrieveTopClustersMarkers(scr, removeDuplicates=FALSE)
topMarkers <- getClustersMarkers(scr)
topMarkers
```


# Plot a heatmap with positive marker genes

Following the execution of the `retrieveTopClustersMarkers`, CONCLUS offers the option to visualize the marker genes on a heatmap (Figure 9). Below we chose to show the selected 10 marker genes per cluster which should generate a heatmap with 100 genes (10 marker genes x 10 clusters). This is 
convenient for visualization. In practice, the number of genes in this heatmap will be less than 100 because some genes were classified as markers for more than one cluster. This can happen when several clusters correspond to similar cellular types.

After selecting the top markers with the method `retrieveTopClustersMarkers`, the method *plotCellHeatmap* is used to order clusters and genes by similarity (the same order as in the *clusterSimilarityMatrix*) and show 
mean-centered normalized data. Mean-centering allows seeing the relative expression of a gene compared to the mean.

\newline
```{r plotCellHeatmap_marker1, warning=FALSE}
plotCellHeatmap(scr, orderClusters=TRUE, orderGenes=TRUE)
```


The second heatmap (Figure 10) below also shows the order of genes and clusters by similarity but for normalized expression data. As you can see, genes expressed at a level of seven and nine look very similar. It is hard to highlight all the 
differences in expression of both lowly and highly detected genes in one heatmap using normalized data. For this reason, mean-centering helps to solve this issue.

\newline
```{r plotCellHeatmap_marker2, warning=FALSE}
plotCellHeatmap(scr, orderClusters=TRUE, orderGenes=TRUE, meanCentered=FALSE)
```

Alternative order of clusters is by name or by hierarchical clustering as in the default pheatmap function.


# Plot t-SNE colored by expression of a selected gene


*PlotGeneExpression* allows visualizing the normalized expression of one gene in a t-SNE plot. It can be useful to inspect the specificity of top markers. Below are examples of marker genes that define a particular cluster (Figures 11-14).
\newline
```{r plotGeneExpression1}
# Plot gene expression in a selected tSNE plot
# Ccl3, marker gene for clusters 2
plotGeneExpression(scr, "Ccl3")
```

```{r plotGeneExpression2}
# Gp9, marker gene for cluster 6
plotGeneExpression(scr, "Gp9")
```

```{r plotGeneExpression3}
# Fn1, marker gene for cluster 7
plotGeneExpression(scr, "Fn1")
```

```{r plotGeneExpression4}
# Alox5ap, marker gene for cluster 9
plotGeneExpression(scr, "Alox5ap")
```

# Collect publicly available info about marker genes

## Collect information for the top 10 markers for each cluster

`retrieveGenesInfo` retrieves gene information for the selected top markers, from open-source databases and websites of NCBI, MGI, and UniProt. It requires the `retrieveTopMarkers` method to have been run on the object.

\newline
```{r getGenesInfo}
scr <- retrieveGenesInfo(scr)
result <- getGenesInfos(scr)
head(result)
```

*result* contains the following columns:

 - uniprot_gn_symbol: Uniprot gene symbol.
 - clusters: The cluster to which the gene is associated.
 - external_gene_name: The complete gene name.
 - go_id: Gene Ontology (GO) identification number.
 - mgi_description: If the species is mouse, description of the gene on MGI.
 - entrezgene_description: Description of the gene by the Entrez database.
 - gene_biotype: protein coding gene, lincRNA gene, miRNA gene, unclassified non-coding RNA gene, or pseudogene.
 - chromosome_name: The chromosome on which the gene is located.
 - Symbol: Official gene symbol.
 - ensembl_gene_id: ID of the gene in the ensembl database.
 - mgi_id: If the species is mouse, ID of the gene on the MGI database.
 - entrezgene_id: ID of the gene on the entrez database.
 - uniprot_gn_id: ID of the gene on the uniprot database.
  

# Supervised clustering 

Until now, we have been using CONCLUS in an unsupervised fashion. This is a good way to start the analysis of a sc-RNA-seq dataset. However, the knowledge of the biologist remains a crucial asset to get the maximum of the data. 
This is why we have included in CONCLUS, additional options to do supervised analysis (or “manual” clustering) to allow the researcher to use her/his biological knowledge in the CONCLUS workflow. Going back to the example of the 
Bergiers et al. dataset above (cluster similarity heatmap), one can see that some clusters clearly belong to the same family of cells after examining the clusters_similarity matrix generated by CONCLUS.

It is mostly obvious for clusters 9 and 10. In order to figure out what marker genes are defining these families of clusters, one can use manual clustering in CONCLUS to fuse clusters of similar 
nature: i.e. combine clusters 9 and 10 together.
\newline
```{r merging_clusters}
## Retrieving the table indicating to which cluster each cell belongs
clustCellsDf <- retrieveTableClustersCells(scr)

## Replace “10” by “9” to merge 9/10
clustCellsDf$clusters[which(clustCellsDf$clusters == 10)] <- 9

## Modifying the object to take into account the new classification
scrUpdated <- addClustering(scr, clusToAdd=clustCellsDf)
```

Now we can visualize the new results taking into account the new classification:
\newline
```{r addClusteringManually_visualization, results = "hide", message = FALSE, warning = FALSE, fig.keep = 'none'}
plotCellSimilarity(scrUpdated)
plotClustersSimilarity(scrUpdated)
plotCellHeatmap(scrUpdated, orderClusters=TRUE, orderGenes=TRUE)
```


This heatmap shows that Cd52 and Alox5ap are good markers of cluster 9 (mix of old clusters 9 and 10). We can visualize them in the t-SNE plots below.
\newline
```{r replot1}
# Plot gene expression in a selected tSNE plot
# Cd52, marker gene for clusters 9 (mix of old clusters 9 and 10)
plotGeneExpression(scrUpdated, "Cd52")
```


```{r replot2}
# Alox5ap, marker gene for cluster 9 (mix of old clusters 9 and 10)
plotGeneExpression(scrUpdated, "Alox5ap")
```

# Conclusion

  Here we demonstrated how to use CONCLUS and combine multiple parameters testing for sc-RNA-seq analysis. It allowed us to gain more information on the dataset of Bergiers et al and will help gaining deeper insights into others. 
  
  Indeed in the original analysis using PCA, two major clusters were found (one composed of i8TFs_plus cells and another comprising E_minus, E_plus, i8TFs_minus cells). Using CONCLUS, we see that there is still a big 
difference between the i8TFs_plus experimental group and the other three. Interestingly, CONCLUS was able to unveil heterogeneity within the i8TFs group while the previous analysis performed by Bergiers et al was not able to reveal it. 
This analysis offers additional information on the function of these eight transcription factors. 

# Session info
This section lists all the packages used for the CONCLUS tool.
```{r sessionInfo}
sessionInfo()
```
